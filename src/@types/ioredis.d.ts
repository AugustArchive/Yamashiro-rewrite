declare module 'ioredis' {
    import { EventEmitter } from 'events';
    import { Readable } from 'stream';
    import tls = require('tls');

    type KeyType = string | Buffer;
    interface IRedisStatic {
        new (port?: string, host?: string, options?: RedisOptions): Redis;
        new (host?: string, options?: RedisOptions): Redis;
        new (options?: RedisOptions): Redis;
        (port?: number, host?: string, options?: RedisOptions): Redis;
        (host?: string, options?: RedisOptions): Redis;
        (options?: RedisOptions): Redis;
        Cluster: IClusterStatic;
        Command: Command;
    }
    interface CommandDefintion {
        numberOfKeys?: number;
        lua?: string;
    }
    class Commander {
        getBuiltinCommands(): string[];
        createBuiltinCommand(name: string): {};
        defineCommand(name: string, defintion: CommandDefintion): any;
    }
    interface Command {
        setArgumentTransformer(name: string, fn: (args: any[]) => any[]): void;
        setReplyTransformer(name: string, fn: (res: any) => any): void;
    }
    interface Redis extends EventEmitter, Commander {
        Promise: typeof Promise;
        status: string;
        connect(cb?: () => void): Promise<any>;
        disconnect(): void;
        duplicate(): Redis;
        send_command(command: string, ...values: any[]): any;
        bitcount(key: KeyType, callback: (error: Error, result: number) => void): void;
        bitcount(key: KeyType, start: number, end: number, callback: (error: Error, result: number) => void): void;
        bitcount(key: KeyType): Promise<number>;
        bitcount(key: KeyType, start: number, end: number): Promise<number>;
        get(key: KeyType, callback: (error: Error, result: string | null) => void): void;
        get(key: KeyType): Promise<string | null>;
        getBuffer(key: KeyType, callback: (error: Error, result: Buffer) => void): void;
        getBuffer(key: KeyType): Promise<Buffer>;
        set(key: KeyType, value: any, expiryMode?: string | any[], time?: number | string, setMode?: number | string): Promise<string>;
        set(key: KeyType, value: any, callback: (error: Error, result: string) => void): void;
        set(key: KeyType, value: any, setMode: string | any[], callback: (error: Error, result: string) => void): void;
        set(key: KeyType, value: any, expiryMode: string, time: number | string, callback: (error: Error, result: string) => void): void;
        set(key: KeyType, value: any, expiryMode: string, time: number | string, setMode: number | string, callback: (error: Error, result: string) => void): void;
        setBuffer(key: KeyType, value: any, expiryMode?: string | any[], time?: number | string, setMode?: number | string): Promise<Buffer>;
        setBuffer(key: KeyType, value: any, callback: (error: Error, result: Buffer) => void): void;
        setBuffer(key: KeyType, value: any, setMode: string, callback: (error: Error, result: Buffer) => void): void;
        setBuffer(key: KeyType, value: any, expiryMode: string, time: number, callback: (error: Error, result: Buffer) => void): void;
        setBuffer(key: KeyType, value: any, expiryMode: string, time: number | string, setMode: number | string, callback: (error: Error, result: Buffer) => void): void;
        setnx(key: KeyType, value: any, callback: (error: Error, result: any) => void): void;
        setnx(key: KeyType, value: any): Promise<any>;
        setex(key: KeyType, seconds: number, value: any, callback: (error: Error, result: any) => void): void;
        setex(key: KeyType, seconds: number, value: any): Promise<any>;
        psetex(key: KeyType, milliseconds: number, value: any, callback: (error: Error, result: any) => void): void;
        psetex(key: KeyType, milliseconds: number, value: any): Promise<any>;
        append(key: KeyType, value: any, callback: (error: Error, result: number) => void): void;
        append(key: KeyType, value: any): Promise<number>;
        strlen(key: KeyType, callback: (error: Error, result: number) => void): void;
        strlen(key: KeyType): Promise<number>;
        del(...keys: KeyType[]): Promise<number>;
        unlink(...keys: KeyType[]): Promise<number>;
        exists(...keys: KeyType[]): Promise<number>;
        exists(key: KeyType, callback: (error: Error, result: number) => void): void;
        setbit(key: KeyType, offset: number, value: any, callback: (err: Error, res: number) => void): void;
        setbit(key: KeyType, offset: number, value: any): Promise<number>;
        getbit(key: KeyType, offset: number, callback: (err: Error, res: number) => void): void;
        getbit(key: KeyType, offset: number): Promise<number>;
        setrange(key: KeyType, offset: number, value: any, callback: (err: Error, res: number) => void): void;
        setrange(key: KeyType, offset: number, value: any): Promise<number>;
        getrange(key: KeyType, start: number, end: number, callback: (err: Error, res: string) => void): void;
        getrange(key: KeyType, start: number, end: number): Promise<string>;
        substr(key: KeyType, start: number, end: number, callback: (err: Error, res: string) => void): void;
        substr(key: KeyType, start: number, end: number): Promise<string>;
        incr(key: KeyType, callback: (err: Error, res: number) => void): void;
        incr(key: KeyType): Promise<number>;
        decr(key: KeyType, callback: (err: Error, res: number) => void): void;
        decr(key: KeyType): Promise<number>;
        mget(...keys: KeyType[]): any;
        rpush(key: KeyType, ...values: any[]): any;
        rpushBuffer(key: string, ...values: Buffer[]): any;
        lpush(key: KeyType, ...values: any[]): any;
        rpushx(key: KeyType, value: any, callback: (err: Error, res: number) => void): void;
        rpushx(key: KeyType, value: any): Promise<number>;
        lpushx(key: KeyType, value: any, callback: (err: Error, res: number) => void): void;
        lpushx(key: KeyType, value: any): Promise<number>;
        linsert(key: KeyType, direction: 'BEFORE' | 'AFTER', pivot: string, value: any, callback: (err: Error, res: number) => void): void;
        linsert(key: KeyType, direction: 'BEFORE' | 'AFTER', pivot: string, value: any): Promise<number>;
        rpop(key: KeyType, callback: (err: Error, res: string) => void): void;
        rpop(key: KeyType): Promise<string>;
        lpop(key: KeyType, callback: (err: Error, res: string) => void): void;
        lpop(key: KeyType): Promise<string>;
        lpopBuffer(key: KeyType, callback: (err: Error, res: Buffer) => void): void;
        lpopBuffer(key: KeyType): Promise<Buffer>;
        brpop(...keys: KeyType[]): any;
        blpop(...keys: KeyType[]): any;
        brpoplpush(source: string, destination: string, timeout: number, callback: (err: Error, res: any) => void): void;
        brpoplpush(source: string, destination: string, timeout: number): Promise<any>;
        llen(key: KeyType, callback: (err: Error, res: number) => void): void;
        llen(key: KeyType): Promise<number>;
        lindex(key: KeyType, index: number, callback: (err: Error, res: string) => void): void;
        lindex(key: KeyType, index: number): Promise<string>;
        lset(key: KeyType, index: number, value: any, callback: (err: Error, res: any) => void): void;
        lset(key: KeyType, index: number, value: any): Promise<any>;
        lrange(key: KeyType, start: number, stop: number, callback: (err: Error, res: any) => void): void;
        lrange(key: KeyType, start: number, stop: number): Promise<any>;
        lrangeBuffer(key: KeyType, start: number, stop: number, callback: (err: Error, res: Buffer[]) => void): void;
        lrangeBuffer(key: KeyType, start: number, stop: number): Promise<Buffer[]>;        
        ltrim(key: KeyType, start: number, stop: number, callback: (err: Error, res: any) => void): void;
        ltrim(key: KeyType, start: number, stop: number): Promise<any>;
        lrem(key: KeyType, count: number, value: any, callback: (err: Error, res: number) => void): void;
        lrem(key: KeyType, count: number, value: any): Promise<number>;
        rpoplpush(source: string, destination: string, callback: (err: Error, res: string) => void): void;
        rpoplpush(source: string, destination: string): Promise<string>;
        rpoplpushBuffer(source: string, destination: string, callback: (err: Error, res: Buffer) => void): void;
        rpoplpushBuffer(source: string, destination: string): Promise<Buffer>;
        sadd(key: KeyType, ...members: any[]): any;
        srem(key: KeyType, ...members: any[]): any;
        smove(source: string, destination: string, member: string, callback: (err: Error, res: string) => void): void;
        smove(source: string, destination: string, member: string): Promise<string>;
        sismember(key: KeyType, member: string, callback: (err: Error, res: 1 | 0) => void): void;
        sismember(key: KeyType, member: string): Promise<1 | 0>;
        scard(key: KeyType, callback: (err: Error, res: number) => void): void;
        scard(key: KeyType): Promise<number>;
        spop(key: KeyType, callback: (err: Error, res: any) => void): void;
        spop(key: KeyType, count: number, callback: (err: Error, res: any) => void): void;
        spop(key: KeyType, count?: number): Promise<any>;
        srandmember(key: KeyType, callback: (err: Error, res: any) => void): void;
        srandmember(key: KeyType, count: number, callback: (err: Error, res: any) => void): void;
        srandmember(key: KeyType, count?: number): Promise<any>;
        sinter(...keys: KeyType[]): any;
        sinterstore(destination: string, ...keys: KeyType[]): any;
        sunion(...keys: KeyType[]): any;
        sunionstore(destination: string, ...keys: KeyType[]): any;
        sdiff(...keys: KeyType[]): any;
        sdiffstore(destination: string, ...keys: KeyType[]): any;
        smembers(key: KeyType, callback: (err: Error, res: any) => void): void;
        smembers(key: KeyType): Promise<any>;
        zadd(key: KeyType, ...args: string[]): Promise<number | string>;
        zaddBuffer(key: KeyType, score1: number, member1: Buffer): Promise<string | number>;
        zincrby(key: KeyType, increment: number, member: string, callback: (err: Error, res: any) => void): void;
        zincrby(key: KeyType, increment: number, member: string): Promise<any>;
        zrem(key: KeyType, ...members: any[]): any;
        zremrangebyscore(key: KeyType, min: number | string, max: number | string, callback: (err: Error, res: any) => void): void;
        zremrangebyscore(key: KeyType, min: number | string, max: number | string): Promise<any>;
        zremrangebyrank(key: KeyType, start: number, stop: number, callback: (err: Error, res: any) => void): void;
        zremrangebyrank(key: KeyType, start: number, stop: number): Promise<any>;
        zunionstore(destination: string, numkeys: number, key: KeyType, ...args: string[]): any;
        zinterstore(destination: string, numkeys: number, key: KeyType, ...args: string[]): any;
        zrange(key: KeyType, start: number, stop: number, callback: (err: Error, res: any) => void): void;
        zrange(key: KeyType, start: number, stop: number, withScores: 'WITHSCORES', callback: (err: Error, res: any) => void): void;
        zrange(key: KeyType, start: number, stop: number, withScores?: 'WITHSCORES'): Promise<any>;
        zrevrange(key: KeyType, start: number, stop: number, callback: (err: Error, res: any) => void): void;
        zrevrange(key: KeyType, start: number, stop: number, withScores: 'WITHSCORES', callback: (err: Error, res: any) => void): void;
        zrevrange(key: KeyType, start: number, stop: number, withScores?: 'WITHSCORES'): Promise<any>;
        zrangebyscore(key: KeyType, min: number | string, max: number | string, ...args: string[]): any;
        zrevrangebyscore(key: KeyType, max: number | string, min: number | string, ...args: string[]): any;
        zcount(key: KeyType, min: number | string, max: number | string, callback: (err: Error, res: number) => void): void;
        zcount(key: KeyType, min: number | string, max: number | string): Promise<number>;
        zcard(key: KeyType, callback: (err: Error, res: number) => void): void;
        zcard(key: KeyType): Promise<number>;
        zscore(key: KeyType, member: string, callback: (err: Error, res: string) => void): void;
        zscore(key: KeyType, member: string): Promise<string>;
        zrank(key: KeyType, member: string, callback: (err: Error, res: number | null) => void): void;
        zrank(key: KeyType, member: string): Promise<number | null>;
        zrevrank(key: KeyType, member: string, callback: (err: Error, res: number | null) => void): void;
        zrevrank(key: KeyType, member: string): Promise<number | null>;
        hset(key: KeyType, field: string, value: any, callback: (err: Error, res: 0 | 1) => void): void;
        hset(key: KeyType, field: string, value: any): Promise<0 | 1>;
        hsetBuffer(key: KeyType, field: string, value: any, callback: (err: Error, res: 0 | 1) => void): void;
        hsetBuffer(key: KeyType, field: string, value: any): Promise<Buffer>;
        hsetnx(key: KeyType, field: string, value: any, callback: (err: Error, res: 0 | 1) => void): void;
        hsetnx(key: KeyType, field: string, value: any): Promise<0 | 1>;
        hget(key: KeyType, field: string, callback: (err: Error, res: string | null) => void): void;
        hget(key: KeyType, field: string): Promise<string | null>;
        hgetBuffer(key: KeyType, field: string, callback: (err: Error, res: Buffer) => void): void;
        hgetBuffer(key: KeyType, field: string): Promise<Buffer>;
        hmset(key: KeyType, ...args: any[]): Promise<0 | 1>;
        hmset(key: KeyType, data: any, callback: (err: Error, res: 0 | 1) => void): void;
        hmset(key: KeyType, data: any): Promise<0 | 1>;
        hmget(key: KeyType, ...fields: string[]): any;
        hincrby(key: KeyType, field: string, increment: number, callback: (err: Error, res: number) => void): void;
        hincrby(key: KeyType, field: string, increment: number): Promise<number>;
        hincrbyfloat(key: KeyType, field: string, increment: number, callback: (err: Error, res: number) => void): void;
        hincrbyfloat(key: KeyType, field: string, increment: number): Promise<number>;
        hdel(key: KeyType, ...fields: string[]): any;
        hlen(key: KeyType, callback: (err: Error, res: number) => void): void;
        hlen(key: KeyType): Promise<number>;        
        hkeys(key: KeyType, callback: (err: Error, res: any) => void): void;
        hkeys(key: KeyType): Promise<any>;
        hvals(key: KeyType, callback: (err: Error, res: any) => void): void;
        hvals(key: KeyType): Promise<any>;
        hgetall(key: KeyType, callback: (err: Error, res: any) => void): void;
        hgetall(key: KeyType): Promise<any>;
        hexists(key: KeyType, field: string, callback: (err: Error, res: 0 | 1) => void): void;
        hexists(key: KeyType, field: string): Promise<0 | 1>;
        incrby(key: KeyType, increment: number, callback: (err: Error, res: number) => void): void;
        incrby(key: KeyType, increment: number): Promise<number>;
        incrbyfloat(key: KeyType, increment: number, callback: (err: Error, res: number) => void): void;
        incrbyfloat(key: KeyType, increment: number): Promise<number>;
        decrby(key: KeyType, decrement: number, callback: (err: Error, res: number) => void): void;
        decrby(key: KeyType, decrement: number): Promise<number>;
        getset(key: KeyType, value: any, callback: (err: Error, res: string | null) => void): void;
        getset(key: KeyType, value: any): Promise<string | null>;
        mset(...args: any[]): any;
        mset(data: any, callback: (err: Error, res: string) => void): void;
        mset(data: any): Promise<string>;
        msetnx(...args: any[]): any;
        msetnx(data: any, callback: (err: Error, res: 0 | 1) => void): void;
        msetnx(data: any): Promise<0 | 1>;
        randomkey(callback: (err: Error, res: string) => void): void;
        randomkey(): Promise<string>;
        select(index: number, callback: (err: Error, res: string) => void): void;
        select(index: number): Promise<string>;
        move(key: KeyType, db: string, callback: (err: Error, res: 0 | 1) => void): void;
        move(key: KeyType, db: string): Promise<0 | 1>;
        rename(key: KeyType, newkey: KeyType, callback: (err: Error, res: string) => void): void;
        rename(key: KeyType, newkey: KeyType): Promise<string>;
        renamenx(key: KeyType, newkey: KeyType, callback: (err: Error, res: 0 | 1) => void): void;
        renamenx(key: KeyType, newkey: KeyType): Promise<0 | 1>;
        expire(key: KeyType, seconds: number, callback: (err: Error, res: 0 | 1) => void): void;
        expire(key: KeyType, seconds: number): Promise<0 | 1>;
        pexpire(key: KeyType, milliseconds: number, callback: (err: Error, res: 0 | 1) => void): void;
        pexpire(key: KeyType, milliseconds: number): Promise<0 | 1>;
        expireat(key: KeyType, timestamp: number, callback: (err: Error, res: 0 | 1) => void): void;
        expireat(key: KeyType, timestamp: number): Promise<0 | 1>;
        pexpireat(key: KeyType, millisecondsTimestamp: number, callback: (err: Error, res: 0 | 1) => void): void;
        pexpireat(key: KeyType, millisecondsTimestamp: number): Promise<0 | 1>;
        keys(pattern: string, callback: (err: Error, res: string[]) => void): void;
        keys(pattern: string): Promise<string[]>;
        dbsize(callback: (err: Error, res: number) => void): void;
        dbsize(): Promise<number>;
        auth(password: string, callback: (err: Error, res: string) => void): void;
        auth(password: string): Promise<string>;
        ping(callback: (err: Error, res: string) => void): void;
        ping(message: string, callback: (err: Error, res: string) => void): void;
        ping(message?: string): Promise<string>;
        echo(message: string, callback: (err: Error, res: string) => void): void;
        echo(message: string): Promise<string>;
        save(callback: (err: Error, res: string) => void): void;
        save(): Promise<string>;
        bgsave(callback: (err: Error, res: string) => void): void;
        bgsave(): Promise<string>;
        bgrewriteaof(callback: (err: Error, res: string) => void): void;
        bgrewriteaof(): Promise<string>;
        shutdown(save: 'SAVE' | 'NOSAVE', callback: (err: Error, res: any) => void): void;
        shutdown(save: 'SAVE' | 'NOSAVE'): Promise<any>;
        lastsave(callback: (err: Error, res: number) => void): void;
        lastsave(): Promise<number>;
        type(key: KeyType, callback: (err: Error, res: string) => void): void;
        type(key: KeyType): Promise<string>;
        multi(commands?: string[][], options?: MultiOptions): RedisPipeline;
        multi(options: { RedisPipeline: false }): Promise<string>;
        exec(callback: (err: Error, res: any) => void): void;
        exec(): Promise<any>;
        discard(callback: (err: Error, res: any) => void): void;
        discard(): Promise<any>;
        sync(callback: (err: Error, res: any) => void): void;
        sync(): Promise<any>;
        flushdb(callback: (err: Error, res: string) => void): void;
        flushdb(): Promise<string>;
        flushall(callback: (err: Error, res: string) => void): void;
        flushall(): Promise<string>;
        sort(key: KeyType, ...args: string[]): any;
        info(callback: (err: Error, res: any) => void): void;
        info(section: string, callback: (err: Error, res: any) => void): void;
        info(section?: string): Promise<string>;
        time(callback: (err: Error, res: any) => void): void;
        time(): Promise<any>;
        monitor(callback: (error: Error, monitor: EventEmitter) => void): void;
        monitor(): Promise<EventEmitter>;
        ttl(key: KeyType, callback: (err: Error, res: number) => void): void;
        ttl(key: KeyType): Promise<number>;
        pttl(key: KeyType, callback: (err: Error, res: number) => void): void;
        pttl(key: KeyType): Promise<number>;
        persist(key: KeyType, callback: (err: Error, res: 0 | 1) => void): void;
        persist(key: KeyType): Promise<0 | 1>;
        slaveof(host: string, port: number, callback: (err: Error, res: string) => void): void;
        slaveof(host: string, port: number): Promise<string>;
        debug(...args: any[]): any;
        config(...args: any[]): any;
        subscribe(...channels: any[]): any;
        unsubscribe(...channels: string[]): any;
        psubscribe(...patterns: string[]): any;
        punsubscribe(...patterns: string[]): any;
        publish(channel: string, message: string, callback: (err: Error, res: number) => void): void;
        publish(channel: string, message: string): Promise<number>;
        publishBuffer(channel: string, message: Buffer): Promise<number>;
        watch(...keys: KeyType[]): any;
        unwatch(callback: (err: Error, res: string) => void): void;
        unwatch(): Promise<string>;
        cluster(...args: any[]): any;
        restore(...args: any[]): any;
        migrate(...args: any[]): any;
        dump(key: KeyType, callback: (err: Error, res: string) => void): void;
        dump(key: KeyType): Promise<string>;
        object(subcommand: string, ...args: any[]): any;
        client(...args: any[]): any;
        eval(...args: any[]): any;
        evalsha(...args: any[]): any;
        script(...args: any[]): any;
        quit(callback: (err: Error, res: string) => void): void;
        quit(): Promise<string>;
        scan(cursor: number): Promise<[string, string[]]>;
        scan(cursor: number, matchOption: 'match' | 'MATCH', pattern: string): Promise<[string, string[]]>;
        scan(cursor: number, countOption: 'count' | 'COUNT', count: number): Promise<[string, string[]]>;
        scan(cursor: number, matchOption: 'match' | 'MATCH', pattern: string, countOption: 'count' | 'COUNT', count: number): Promise<[string, string[]]>;
        scan(cursor: number, countOption: 'count' | 'COUNT', count: number, matchOption: 'match' | 'MATCH', pattern: string): Promise<[string, string[]]>;
        sscan(key: KeyType, cursor: number, ...args: any[]): any;
        hscan(key: KeyType, cursor: number, ...args: any[]): any;
        zscan(key: KeyType, cursor: number, ...args: any[]): any;
        pfmerge(destkey: KeyType, ...sourcekeys: KeyType[]): any;
        pfadd(key: KeyType, ...elements: string[]): any;
        pfcount(...keys: KeyType[]): any;
        RedisPipeline(commands?: string[][]): RedisPipeline;
        scanStream(options?: ScanStreamOption): Readable;
        sscanStream(key: KeyType, options?: ScanStreamOption): Readable;
        hscanStream(key: KeyType, options?: ScanStreamOption): Readable;
        zscanStream(key: KeyType, options?: ScanStreamOption): Readable;
        xack(key: KeyType, group: string, ...ids: string[]): any;
        xadd(key: KeyType, id: string, ...args: string[]): any;
        xadd(key: KeyType, maxLenOption: 'MAXLEN' | 'maxlen', count: number, ...args: string[]): any;
        xadd(key: KeyType, maxLenOption: 'MAXLEN' | 'maxlen', approximate: '~', count: number, ...args: string[]): any;
        xclaim(key: KeyType, group: string, consumer: string, minIdleTime: number, ...args: any[]): any;
        xdel(key: KeyType, ...ids: string[]): any;
        xgroup(...args: any[]): any;
        xinfo(...args: any[]): any;
        xlen(key: KeyType): any;
        xpending(key: KeyType, group: string, ...args: any[]): any;
        xrange(key: KeyType, start: string, end: string, ...args: any[]): any;
        xread(...args: any[]): any;
        xreadgroup(groupOption: 'GROUP' | 'group', group: string, consumer: string,  ...args: any[]): any;
        xrevrange(key: KeyType, end: string, start: string, ...args: any[]): any;
        xtrim(key: KeyType, maxLenOption: 'MAXLEN' | 'maxlen', ...args: any[]): any;
    }
    interface RedisPipeline {
        redis: Redis;
        isCluster: boolean;
        options: RedisOptions;
        _queue: Command[];
        _result: any[];
        _transactions: number;
        _shaToScript: {};
        bitcount(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        bitcount(key: KeyType, start: number, end: number, callback?: (err: Error, res: number) => void): RedisPipeline;
        get(key: KeyType, callback?: (err: Error, res: string) => void): RedisPipeline;
        getBuffer(key: KeyType, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        set(key: KeyType, value: any, callback?: (err: Error, res: string) => void): RedisPipeline;
        set(key: KeyType, value: any, setMode: string, callback?: (err: Error, res: string) => void): RedisPipeline;
        set(key: KeyType, value: any, expiryMode: string, time: number, callback?: (err: Error, res: string) => void): RedisPipeline;
        set(key: KeyType, value: any, expiryMode: string, time: number, setMode: string, callback?: (err: Error, res: string) => void): RedisPipeline;
        setBuffer(key: KeyType, value: any, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        setBuffer(key: KeyType, value: any, setMode: string, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        setBuffer(key: KeyType, value: any, expiryMode: string, time: number, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        setBuffer(key: KeyType, value: any, expiryMode: string, time: number, setMode: string, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        setnx(key: KeyType, value: any, callback?: (err: Error, res: any) => void): RedisPipeline;
        setex(key: KeyType, seconds: number, value: any, callback?: (err: Error, res: any) => void): RedisPipeline;
        psetex(key: KeyType, milliseconds: number, value: any, callback?: (err: Error, res: any) => void): RedisPipeline;
        append(key: KeyType, value: any, callback?: (err: Error, res: number) => void): RedisPipeline;
        strlen(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        del(...keys: KeyType[]): RedisPipeline;
        exists(...keys: KeyType[]): RedisPipeline;
        setbit(key: KeyType, offset: number, value: any, callback?: (err: Error, res: number) => void): RedisPipeline;
        getbit(key: KeyType, offset: number, callback?: (err: Error, res: number) => void): RedisPipeline;
        setrange(key: KeyType, offset: number, value: any, callback?: (err: Error, res: number) => void): RedisPipeline;
        getrange(key: KeyType, start: number, end: number, callback?: (err: Error, res: string) => void): RedisPipeline;
        substr(key: KeyType, start: number, end: number, callback?: (err: Error, res: string) => void): RedisPipeline;
        incr(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        decr(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        mget(...keys: KeyType[]): RedisPipeline;
        rpush(key: KeyType, ...values: any[]): RedisPipeline;
        rpushBuffer(key: string, ...values: Buffer[]): RedisPipeline;
        lpush(key: KeyType, ...values: any[]): RedisPipeline;
        rpushx(key: KeyType, value: any, callback?: (err: Error, res: number) => void): RedisPipeline;
        lpushx(key: KeyType, value: any, callback?: (err: Error, res: number) => void): RedisPipeline;
        linsert(key: KeyType, direction: 'BEFORE' | 'AFTER', pivot: string, value: any, callback?: (err: Error, res: number) => void): RedisPipeline;
        rpop(key: KeyType, callback?: (err: Error, res: string) => void): RedisPipeline;
        lpop(key: KeyType, callback?: (err: Error, res: string) => void): RedisPipeline;
        lpopBuffer(key: KeyType, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        brpop(...keys: KeyType[]): RedisPipeline;
        blpop(...keys: KeyType[]): RedisPipeline;
        brpoplpush(source: string, destination: string, timeout: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        llen(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        lindex(key: KeyType, index: number, callback?: (err: Error, res: string) => void): RedisPipeline;
        lset(key: KeyType, index: number, value: any, callback?: (err: Error, res: any) => void): RedisPipeline;
        lrange(key: KeyType, start: number, stop: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        lrangeBuffer(key: KeyType, start: number, stop: number, callback?: (err: Error, res: Buffer[]) => void): RedisPipeline;
        ltrim(key: KeyType, start: number, stop: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        lrem(key: KeyType, count: number, value: any, callback?: (err: Error, res: number) => void): RedisPipeline;
        rpoplpush(source: string, destination: string, callback?: (err: Error, res: string) => void): RedisPipeline;
        sadd(key: KeyType, ...members: any[]): RedisPipeline;
        srem(key: KeyType, ...members: any[]): RedisPipeline;
        smove(source: string, destination: string, member: string, callback?: (err: Error, res: string) => void): RedisPipeline;
        sismember(key: KeyType, member: string, callback?: (err: Error, res: 1 | 0) => void): RedisPipeline;
        scard(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        spop(key: KeyType, callback?: (err: Error, res: any) => void): RedisPipeline;
        spop(key: KeyType, count: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        srandmember(key: KeyType, callback?: (err: Error, res: any) => void): RedisPipeline;
        srandmember(key: KeyType, count: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        sinter(...keys: KeyType[]): RedisPipeline;
        sinterstore(destination: string, ...keys: KeyType[]): RedisPipeline;
        sunion(...keys: KeyType[]): RedisPipeline;
        sunionstore(destination: string, ...keys: KeyType[]): RedisPipeline;
        sdiff(...keys: KeyType[]): RedisPipeline;
        sdiffstore(destination: string, ...keys: KeyType[]): RedisPipeline;
        smembers(key: KeyType, callback?: (err: Error, res: any) => void): RedisPipeline;
        zadd(key: KeyType, ...args: string[]): RedisPipeline;
        zincrby(key: KeyType, increment: number, member: string, callback?: (err: Error, res: any) => void): RedisPipeline;
        zrem(key: KeyType, ...members: any[]): RedisPipeline;
        zremrangebyscore(key: KeyType, min: number | string, max: number | string, callback?: (err: Error, res: any) => void): RedisPipeline;
        zremrangebyrank(key: KeyType, start: number, stop: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        zunionstore(destination: string, numkeys: number, key: KeyType, ...args: string[]): RedisPipeline;
        zinterstore(destination: string, numkeys: number, key: KeyType, ...args: string[]): RedisPipeline;
        zrange(key: KeyType, start: number, stop: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        zrange(key: KeyType, start: number, stop: number, withScores: 'WITHSCORES', callback?: (err: Error, res: any) => void): RedisPipeline;
        zrevrange(key: KeyType, start: number, stop: number, callback?: (err: Error, res: any) => void): RedisPipeline;
        zrevrange(key: KeyType, start: number, stop: number, withScores: 'WITHSCORES', callback?: (err: Error, res: any) => void): RedisPipeline;
        zrangebyscore(key: KeyType, min: number | string, max: number | string, ...args: string[]): RedisPipeline;
        zrevrangebyscore(key: KeyType, max: number | string, min: number | string, ...args: string[]): RedisPipeline;
        zcount(key: KeyType, min: number | string, max: number | string, callback?: (err: Error, res: number) => void): RedisPipeline;
        zcard(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        zscore(key: KeyType, member: string, callback?: (err: Error, res: number) => void): RedisPipeline;
        zrank(key: KeyType, member: string, callback?: (err: Error, res: number) => void): RedisPipeline;
        zrevrank(key: KeyType, member: string, callback?: (err: Error, res: number) => void): RedisPipeline;
        hset(key: KeyType, field: string, value: any, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        hsetBuffer(key: KeyType, field: string, value: any, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        hsetnx(key: KeyType, field: string, value: any, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        hget(key: KeyType, field: string, callback?: (err: Error, res: string | string) => void): RedisPipeline;
        hgetBuffer(key: KeyType, field: string, callback?: (err: Error, res: Buffer) => void): RedisPipeline;
        hmset(key: KeyType, ...args: any[]): RedisPipeline;
        hmset(key: KeyType, data: any, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        hmget(key: KeyType, ...fields: string[]): RedisPipeline;
        hincrby(key: KeyType, field: string, increment: number, callback?: (err: Error, res: number) => void): RedisPipeline;
        hincrbyfloat(key: KeyType, field: string, increment: number, callback?: (err: Error, res: number) => void): RedisPipeline;
        hdel(key: KeyType, ...fields: string[]): RedisPipeline;
        hlen(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        hkeys(key: KeyType, callback?: (err: Error, res: any) => void): RedisPipeline;
        hvals(key: KeyType, callback?: (err: Error, res: any) => void): RedisPipeline;
        hgetall(key: KeyType, callback?: (err: Error, res: any) => void): RedisPipeline;
        hexists(key: KeyType, field: string, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        incrby(key: KeyType, increment: number, callback?: (err: Error, res: number) => void): RedisPipeline;
        incrbyfloat(key: KeyType, increment: number, callback?: (err: Error, res: number) => void): RedisPipeline;
        decrby(key: KeyType, decrement: number, callback?: (err: Error, res: number) => void): RedisPipeline;
        getset(key: KeyType, value: any, callback?: (err: Error, res: string) => void): RedisPipeline;
        mset(...args: any[]): RedisPipeline;
        mset(data: any, callback?: (err: Error, res: string) => void): RedisPipeline;
        msetnx(...args: any[]): RedisPipeline;
        msetnx(data: any, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        randomkey(callback?: (err: Error, res: string) => void): RedisPipeline;
        select(index: number, callback?: (err: Error, res: string) => void): RedisPipeline;
        move(key: KeyType, db: string, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        rename(key: KeyType, newkey: KeyType, callback?: (err: Error, res: string) => void): RedisPipeline;
        renamenx(key: KeyType, newkey: KeyType, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        expire(key: KeyType, seconds: number, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        pexpire(key: KeyType, milliseconds: number, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        expireat(key: KeyType, timestamp: number, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        pexpireat(key: KeyType, millisecondsTimestamp: number, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        keys(pattern: string, callback?: (err: Error, res: string[]) => void): RedisPipeline;
        dbsize(callback?: (err: Error, res: number) => void): RedisPipeline;
        auth(password: string, callback?: (err: Error, res: string) => void): RedisPipeline;
        ping(callback?: (err: Error, res: string) => void): RedisPipeline;
        ping(message: string, callback?: (err: Error, res: string) => void): RedisPipeline;
        echo(message: string, callback?: (err: Error, res: string) => void): RedisPipeline;
        save(callback?: (err: Error, res: string) => void): RedisPipeline;
        bgsave(callback?: (err: Error, res: string) => void): RedisPipeline;
        bgrewriteaof(callback?: (err: Error, res: string) => void): RedisPipeline;
        shutdown(save: 'SAVE' | 'NOSAVE', callback?: (err: Error, res: any) => void): RedisPipeline;
        lastsave(callback?: (err: Error, res: number) => void): RedisPipeline;
        type(key: KeyType, callback?: (err: Error, res: string) => void): RedisPipeline;
        multi(callback?: (err: Error, res: string) => void): RedisPipeline;
        exec(callback?: (err: Error, res: any) => void): Promise<any>;
        discard(callback?: (err: Error, res: any) => void): RedisPipeline;
        sync(callback?: (err: Error, res: any) => void): RedisPipeline;
        flushdb(callback?: (err: Error, res: string) => void): RedisPipeline;
        flushall(callback?: (err: Error, res: string) => void): RedisPipeline;
        sort(key: KeyType, ...args: string[]): RedisPipeline;
        info(callback?: (err: Error, res: any) => void): RedisPipeline;
        info(section: string, callback?: (err: Error, res: any) => void): RedisPipeline;
        time(callback?: (err: Error, res: any) => void): RedisPipeline;
        monitor(callback?: (err: Error, res: EventEmitter) => void): RedisPipeline;
        ttl(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        pttl(key: KeyType, callback?: (err: Error, res: number) => void): RedisPipeline;
        persist(key: KeyType, callback?: (err: Error, res: 0 | 1) => void): RedisPipeline;
        slaveof(host: string, port: number, callback?: (err: Error, res: string) => void): RedisPipeline;
        debug(...args: any[]): RedisPipeline;
        config(...args: any[]): RedisPipeline;
        subscribe(...channels: any[]): RedisPipeline;
        unsubscribe(...channels: string[]): RedisPipeline;
        psubscribe(...patterns: string[]): RedisPipeline;
        punsubscribe(...patterns: string[]): RedisPipeline;
        publish(channel: string, message: string, callback?: (err: Error, res: number) => void): RedisPipeline;
        watch(...keys: KeyType[]): RedisPipeline;
        unwatch(callback?: (err: Error, res: string) => void): RedisPipeline;
        cluster(...args: any[]): RedisPipeline;
        restore(...args: any[]): RedisPipeline;
        migrate(...args: any[]): RedisPipeline;
        dump(key: KeyType, callback?: (err: Error, res: string) => void): RedisPipeline;
        object(subcommand: string, ...args: any[]): RedisPipeline;
        client(...args: any[]): RedisPipeline;
        eval(...args: any[]): RedisPipeline;
        evalsha(...args: any[]): RedisPipeline;
        script(...args: any[]): RedisPipeline;
        quit(callback?: (err: Error, res: string) => void): RedisPipeline;
        scan(cursor: number): RedisPipeline;
        scan(cursor: number, matchOption: 'match' | 'MATCH', pattern: string): RedisPipeline;
        scan(cursor: number, countOption: 'count' | 'COUNT', count: number): RedisPipeline;
        scan(cursor: number, matchOption: 'match' | 'MATCH', pattern: string, countOption: 'count' | 'COUNT', count: number): RedisPipeline;
        scan(cursor: number, countOption: 'count' | 'COUNT', count: number, matchOption: 'match' | 'MATCH', pattern: string): RedisPipeline;
        sscan(key: KeyType, cursor: number, ...args: any[]): RedisPipeline;
        hscan(key: KeyType, cursor: number, ...args: any[]): RedisPipeline;
        zscan(key: KeyType, cursor: number, ...args: any[]): RedisPipeline;
        pfmerge(destkey: KeyType, ...sourcekeys: KeyType[]): RedisPipeline;
        pfadd(key: KeyType, ...elements: string[]): RedisPipeline;
        pfcount(...keys: KeyType[]): RedisPipeline;
        xack(key: KeyType, group: string, ...ids: string[]): RedisPipeline;
        xadd(key: KeyType, id: string, ...args: string[]): RedisPipeline;
        xclaim(key: KeyType, group: string, consumer: string, minIdleTime: number, id: string, ...args: any[]): RedisPipeline;
        xdel(key: KeyType, ...ids: string[]): RedisPipeline;
        xgroup(...args: any[]): RedisPipeline;
        xinfo(...args: any[]): RedisPipeline;
        xlen(key: KeyType): RedisPipeline;
        xpending(key: KeyType, group: string, ...args: any[]): RedisPipeline;
        xrange(key: KeyType, start: string, end: string, ...args: any[]): RedisPipeline;
        xread(...args: any[]): RedisPipeline;
        xreadgroup(command: 'GROUP' | 'group', group: string, consumer: string,  ...args: any[]): RedisPipeline;
        xrevrange(key: KeyType, end: string, start: string, ...args: any[]): RedisPipeline;
        xtrim(key: KeyType, strategy: 'MAXLEN' | 'maxlen', ...args: any[]): RedisPipeline;
    }

    interface NodeConfiguration {
        host?: string;
        port?: number;
    }

    type Callback<T>  = (error: NodeJS.ErrnoException | null, result?: T) => void;    
    type IClusterNode = (string | number | NodeConfiguration);
    type NodeRole     = 'master' | 'slave' | 'all';
    interface RedisCluster extends EventEmitter, Commander {
        connect(cb: () => void): Promise<any>;
        disconnect(): void;
        nodes(role?: NodeRole): Redis[];
        quit(cb: Callback<'OK'>): Promise<'OK'>;
        get(key: KeyType, callback: Callback<(string | null)>): void;
        get(key: KeyType): Promise<string | null>;
        set(key: KeyType, value: any, expiryMode?: string | any[], time?: number | string, setMode?: number | string): Promise<string>;
        set(key: KeyType, value: any, callback: Callback<string>): void;
        set(key: KeyType, value: any, expiryMode: string, time: number | string, callback: Callback<string>): void;
        set(key: KeyType, value: any, expiryMode: string, time: number | string, setMode: number | string, callback: Callback<string>): void;
    }
    interface IClusterStatic extends EventEmitter, Commander {
        new (nodes: IClusterNode[], options?: ClusterOptions): RedisCluster;
    }
    interface RedisOptions {
        port?: number;
        host?: string;
        family?: number;
        path?: string;
        keepAlive?: number;
        connectionName?: string;
        password?: string;
        db?: number;
        enableReadyCheck?: boolean;
        keyPrefix?: string;
        retryStrategy?(time: number): number | false;
        maxRetriesPerRequest?: number | null;
        reconnectOnError?(error: Error): boolean | 1 | 2;
        connectTimeout?: number;
        autoResubscribe?: boolean;
        autoResendUnfulfilledCommands?: boolean;
        lazyConnect?: boolean;
        tls?: tls.ConnectionOptions;
        sentinels?: { host: string; port: number }[];
        name?: string;
        readOnly?: boolean;
        dropBufferSupport?: boolean;
        showFriendlyErrorStack?: boolean;
    }
    interface ScanStreamOption {
        match?: string;
        count?: number;
    }

    type DNSLookupFunction = (
        hostname: string,
        callback: (error: NodeJS.ErrnoException, address: string, family: number) => void
    ) => void;
    interface NatMap {
        [x: string]: {
            host: string;
            port: number;
        }
    }
    interface ClusterOptions {
        clusterRetryStrategy?(times: number, reason?: Error): number | null;
        enableOfflineQueue?: boolean;
        enableReadyCheck?: boolean;
        scaleReads?: string;
        maxRedirections?: number;
        retryDelayOnFailover?: number;
        retryDelayOnClusterDown?: number;
        retryDelayOnTryAgain?: number;
        slotsRefreshTimeout?: number;
        slotsRefreshInterval?: number;
        redisOptions?: RedisOptions;
        lazyConnect?: boolean;
        dnsLookup?: DNSLookupFunction;
        natMap?: NatMap;
    }
    interface MultiOptions {
        pipeline: boolean;
    }

    const _Redis: IRedisStatic;
    export { Redis };
    export default _Redis;
}